Задача:
```
  В трехмерном пространстве задано множество точек. 
  Найти разбиение этого множество на два непустых непересекающихся множества, 
  чтобы их центры тяжести находились как можно ближе друг к другу. 
```

Для представления точки в трехмерном пространстве используется структура Point.
```c++
struct Point
{
    int x, y, z;
    ...
};
```
Перегруженные операторы соответствуют операциям в трехмерном евклидовом пространстве.
```C++
bool operator==(const Point& p, const Point &q) { ... }
Point operator+(const Point& p, const Point &q) { ... }
Point operator-(const Point& p, const Point &q) { ... }
Point operator*(const Point& p, const Point& q) { ... }
Point operator/(const Point& p, int d) { ... }
```

Множество точек представленно в виде массива
```C++
...
vector<Point> set;
...
```

Для представления подмн-в используется массивы, где истинность i-го элемента означает его принадлежность ко второму подмн-ву,
ложность - к первому подмн-ву.
```C++
...
vector<bool> perm; // используется для получения различных разбиений изначального мн-ва
vector<bool> best; // по окончании поиска содержит искомое разбиение
...
````


```C++
unsigned norm(Point p) { ... }
```
`norm` - Находит норму вектора. В силу эквивалентности метрик используется сумма квадратов координат. 
Расстояние между двумя точками находится как норма их разности.

Процедуры вывода в консоль точки и множества.
```C++
void print(Point const& p) { ... }
void print_set(vector<Point> const& set) { ... }
```
Для вывода подмн-в, полученных в результате поиска, используется индикаторный массив. 
```C++
void print_subset(vector<Point> const& set, vector<bool> const& m) { ... }
```
Изначальное мн-во генерируется функцией, не допускающей наличия одинаковых векторов,
```C++
void get_random_set(vector<Point>& set, size_t cap) { ... }
````
которая использует функцию `rand_point( ... ) { ... }` 
для генерации случайного вектора (в данной реализации только с неотрицательными координатами, 
значения которых меньше, чем 101)

Поиск необходимого разбиения осуществляется рекурсивной процедурой.
Данная процедура не позволяет производить поиск в многопоточном режиме!
```C++
void bt(vector<Point> const& set, vector<bool>& perm, vector<bool>& best, unsigned& min_dist, unsigned pos = 0) { ... }
```
Где
  - `vector<Point> const& set` - изначальное мн-во точек;
  - `vector<bool>& perm` - массив, в котором будут хранится разбиения изначального мн-ва;
  - `vector<bool>& best` - массив, в котором по окончании работы процедуры будет хранится искомое разбиение;
  - `unsigned& min_dist` - переменная, которая хранит минимальное расстояние, которое найдено на данный момент;
  - `unsigned pos = 0` - номер элемента в мн-ве `set`, который надо распределить в одно из подмн-в на данном этапе.

При вызове функции `bt()` из управляющей процедуры параметр `min_dist = -1`, при этом предполагается, что минимальная 
дистанция между мн-вами не превзойдет максимальное число, 
которое может хранить в себе беззнаковое целое. Массивы `best` и `perm` обнулены.

```C++
//функция main
  ...
  unsigned min_dist = -1;
  bt(set, perm, best, min_dist);
  ...
```

Процедура `bt()` рекурсивно перебирает все возможные разбиения изначального мн-ва. Текущее разбиение 
хранится в массиве `perm`. 


На i-ом уровне рекурсии, при фиксированном распределении первых i элементов, 
происходит распределение i-го элемента `(нумерация в массиве с нуля!)` мн-ва в первое подмн-во
(чему соответсвует значение `false` в  `perm[i]`)
и перебор всех вариантов разбиений для элементов начиная с i+1,
```C++
    ...
    bt(set, perm, best, min_dist, pos+1);
    perm[pos] = true;
    ...
```    


Затем, после возврата, распределение i-го элемента во второе подмн-во
(чему соответсвует значение `true` в  `perm[i]`).
```C++
    ...
    perm[pos] = true;
    bt(set, perm, best, min_dist, pos+1);
    perm[pos] = false;
    ...
```

На глубине, равной кол-ву векторов в изначальном мн-ве, в массиве `perm` хранится очередное разбиение.
На данном этапе производится расчет расстояния между подмн-ми данного разбиения.

```C++
  ...
  centre_0 = centre_0/cnt;
  centre_1 = centre_1/(set.size() - cnt);
  dist = norm(centre_1 - centre_0);  
  ...
```
(`centre_0` и `centre_1`  переменные типа `Point`, которые содержат центры подмн-в)
```C++
    ...
    for (unsigned i = 0; i < set.size(); ++i)
    {
        if(perm[i])
        {
           centre_0 = centre_0 + set[i];
           ++cnt;
        }
        else
        {
            centre_1 = centre_1 + set[i];
        }
    }    
   ...
```
Если это расстояние меньше, 
чем раннее найденное, то значение минимального расстояния в переменной `min_dist` изменяется на `dist`,
и в массив `best` записывается текущее разбиение.

```C++
        ...
        if(dist < min_dist)
        {
            min_dist = dist;
            best = perm;
        }
        ...
```
После происходит возврат из функции.
```C++
      ...
      return;
    }
```
